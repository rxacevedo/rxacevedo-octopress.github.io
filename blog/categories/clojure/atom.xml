<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: clojure | Roberto Acevedo]]></title>
  <link href="http://rxacevedo.github.io/blog/categories/clojure/atom.xml" rel="self"/>
  <link href="http://rxacevedo.github.io/"/>
  <updated>2014-05-03T12:22:40-04:00</updated>
  <id>http://rxacevedo.github.io/</id>
  <author>
    <name><![CDATA[Roberto Acevedo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Sierpinski's Triangle]]></title>
    <link href="http://rxacevedo.github.io/blog/2014/02/15/sierpinskis-triangle/"/>
    <updated>2014-02-15T22:36:06-05:00</updated>
    <id>http://rxacevedo.github.io/blog/2014/02/15/sierpinskis-triangle</id>
    <content type="html"><![CDATA[<p>Fractal curves are frequently used to demonstrate recursion in many FP
texts or tutorials. This post will run through the process of rendering
<a href="http://en.wikipedia.org/wiki/Sierpinski_triangle">Sierpinksi&rsquo;s triangle</a>,
one of the most well-known fractals, and also one of the most
straightforward to generate.</p>

<p>We start by determining the coordinates of our outer triangle, as all other
coordinates will be a function of these. This was a bit of a pain in
the ass for me because the JFrame does not use a
<a href="http://en.wikipedia.org/wiki/Cartesian_coordinate_system">cartesian coordinate system</a>,
but rather increases both x and y coordinates by advancing down/to the
right. This means that there are no negative points on the grid. Using
a 500x500 px plane, our triangle&rsquo;s points would be at (250 75), (25
450), and (475 450) for the top, bottom left and bottom right,
respectively.</p>

<p>``` clojure
(def frame
  &ldquo;java.awt.Frame instance&rdquo;
  (doto (Frame.)</p>

<pre><code>(.setVisible true)
(.setSize 500 500)
(.setBackground Color/BLACK)))
</code></pre>

<p>;;&ndash;> nil</p>

<p>(def ^:dynamic gfx
  &ldquo;java.awt.Graphics2D instance&rdquo;
  (doto (.getGraphics frame)</p>

<pre><code>(.setColor Color/WHITE)))
</code></pre>

<p>;;&ndash;> nil</p>

<p>(do
  (.drawLine gfx 250 75 25 450)
  (.drawLine gfx 250 75 475 450)
  (.drawLine gfx 25 450 475 450))
```</p>

<p>You should have a white triangle outline on a black background.</p>

<p><img class="left" src="/images/posts/sierpinski_triangle_fractal/sierpinski_0.png"></p>

<p>The next thing that we need to do is figure out what to do
each time we <code>recur</code>, since our procedure will keep doing that
until it terminates. If we look at the progression of the drawing from
the outside in, we see that there is a
<a href="http://en.wikipedia.org/wiki/Self-similarity">self-similarity</a>
between the outer triangle and those inside of it. For every triangle,
there are three more triangles inside of it. This is the key to our
recursive procedure: <strong>for every one unit of work, we do three units of
work.</strong> What constitutes a unit of work in this case? Well, the most
easily observable thing would be drawing a triangle. If we look
at Sierpinski&rsquo;s triangle, we can see that there are two types of triangles,
the upright (outer) ones, and the inverted (inner) ones. Let&rsquo;s quickly
establish how these two types of triangles should be represented in
our program:</p>

<p>``` clojure
(defn triangle [p1 p2 p3 t-type]
  (condp = t-type</p>

<pre><code>:outer {:top p1 :b-left p2 :b-right p3}
:inner {:t-left p1 :t-right p2 :bottom p3}))
</code></pre>

<p>```</p>

<p>Each triangle is made up of three points. Depending on the <code>t-type</code> we
pass in, our points will be labeled a certain way. This allows us to
specify the type of triangle we are passing to another function.
Looking back at our initial triangle, we can think about what we need
to do in one of two ways:</p>

<ol>
<li>We need to draw three new triangles, the outer triangles.</li>
<li>We need to draw one inverted triangle, the inner triangle.</li>
</ol>


<p>We will need to do this three times for every one, so it would be wise
to choose the least expensive of the two. This makes our decision
straightforward: for every outer triangle, we need to paint its
corresponding inner triangle. Our work still increases as a power of
three each time, but now we are only painting one inner triangle per
unit of work, instead of three outer triangles per unit of work. Since
we know that each recursion requires us to do three more units of
work, this becomes a matter of drawing three inverted triangles per
recursive call, instead of nine outer triangles.</p>

<p>In order to draw the inner triangle for a triangle, we need to
determine its coordinates. We can write a convenience method to do
that for us:</p>

<p>``` clojure
(defn inner [t]
  (let [{:keys [top b-left b-right]} t</p>

<pre><code>    [x1 y1] top
    [x2 y2] b-left
    [x3 y3] b-right]
(triangle (map double [(+ x2 (/ (- x1 x2) 2))
                       (+ y1 (/ (- y2 y1) 2))])
          (map double [(+ x1 (/ (- x3 x1) 2))
                       (+ y1 (/ (- y3 y1) 2))])
          (map double [(+ x2 (/ (- x3 x2) 2))
                       (/ (+ y2 y3) 2)]) :inner)))
</code></pre>

<p>```</p>

<p>This function takes a triangle t, and returns a new triangle map for
the inner triangle with its points labeled. The points are calculated
relative to the points of the outer triangle, which reduces our effort
to that of calculating midpoints. Now we can draw the inner triangle
inside of of the outer triangle that we drew before:</p>

<p><code>clojure
(draw-triangle (inner (triangle [250 75] [25 450] [475 450] :outer)))
</code></p>

<p>The last crucial bit is determining the coordinates of the outer
triangles, since we will need to draw the corresponding inner triangle
for each. Each of these three new triangles is composed of points from
the outer triangle and the inner triangle. This makes it easy for us
to write another convenience method, this time to return three
triangle maps, one for each triangle:</p>

<p>``` clojure
(defn outers [t]
  (let [{[x1 y1] :top</p>

<pre><code>     [x2 y2] :b-left
     [x3 y3] :b-right} t
    {[ix1 iy1] :t-left
     [ix2 iy2] :t-right
     [ix3 iy3] :bottom} (inner t)]
{:top (triangle [x1 y1] [ix1 iy1] [ix2 iy2] :outer)
 :b-left (triangle [ix1 iy1] [x2 y2] [ix3 iy3] :outer)
 :b-right (triangle [ix2 iy2] [ix3 iy3] [x3 y3] :outer)}))
</code></pre>

<p>```</p>

<p>This function takes a triangle t, and returns a map of triangle maps,
each keyed according to which triangle it represents. It takes
advantage of the procedure <code>inner</code> that we just wrote in order to
determine the coordinates of each triangle. Now for each of
these, we can draw its inner:</p>

<p><code>clojure
(doseq [sub-t (vals (outers (triangle [250 75] [25 450] [475 450] :outer)))]
  (draw-triangle (inner sub-t)))
</code></p>

<p>Now that we have a method in place for doing this, we just need to
recursively tie it together. We can write one last function,
<code>sierpinski</code>, that will handle the recursion for us:</p>

<p>``` clojure
(defn sierpinski
  ([]</p>

<pre><code> (sierpinski 10))
</code></pre>

<p>  ([lvl] (sierpinski (triangle [250 75] [25 450] [475 450] :outer) lvl true))
  ([t lvl]</p>

<pre><code> (when (&gt; lvl 0)
   (do
     (draw-triangle (inner t))
     (doseq [sub-t (vals (outers t))]
       (sierpinski sub-t (dec lvl))))))
</code></pre>

<p>  ([t lvl first?]</p>

<pre><code> (if first?
   (do
     (draw-triangle t)
     (sierpinski t lvl false))
   (sierpinski t lvl))))
</code></pre>

<p>```</p>

<p>This function, when invoked with no arguments, defaults to a 10-level
Sierpinski triangle. It assumes our JFrame is of size 500x500 and sets
the initial coordinates accordingly. Since we only want to draw the
first outer triangle, we use a boolean argument to control whether the
triangle is drawn, or just its inner triangle. This is only true for
the first iteration. Each time we <code>recur</code>, we paint our current
triangle&rsquo;s inner triangle, as well as calling the <code>sierpinski</code> method
again on each of the three outer triangles, while decrementing our
level, to do the same thing. These tree-recursive calls to
<code>sierpinski</code> mirror the recursive nature of the image itself. Here is
the full source code for the final program:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span> (sierpinski.clj)</span> <a href='/downloads/code/clojure/sierpinski.clj'>download</a></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
<span class='line-number'>105</span>
<span class='line-number'>106</span>
<span class='line-number'>107</span>
</pre></td><td class='code'><pre><code class='clojure'><span class='line'><span class="p">(</span><span class="kd">ns </span><span class="nv">sierpinski</span>
</span><span class='line'>  <span class="p">(</span><span class="nb">import </span><span class="p">[</span><span class="nv">java.awt</span> <span class="nv">Color</span><span class="p">]</span>
</span><span class='line'>          <span class="p">[</span><span class="nv">java.awt.image</span> <span class="nv">BufferedImage</span><span class="p">]</span>
</span><span class='line'>          <span class="p">[</span><span class="nv">javax.imageio</span> <span class="nv">ImageIO</span><span class="p">]</span>
</span><span class='line'>          <span class="p">[</span><span class="nv">javax.swing</span> <span class="nv">JFrame</span><span class="p">])</span>
</span><span class='line'>  <span class="p">(</span><span class="ss">:gen-class</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="nv">frame</span>
</span><span class='line'>  <span class="s">&quot;java.awt.JFrame instance&quot;</span>
</span><span class='line'>  <span class="p">(</span><span class="nb">doto </span><span class="p">(</span><span class="nf">JFrame.</span><span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">.setVisible</span> <span class="nv">true</span><span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">.setSize</span> <span class="mi">500</span> <span class="mi">500</span><span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">.setBackground</span> <span class="nv">Color/BLACK</span><span class="p">)))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="k">def </span><span class="o">^</span><span class="ss">:dynamic</span> <span class="nv">gfx</span>
</span><span class='line'>  <span class="s">&quot;java.awt.Graphics2D instance&quot;</span>
</span><span class='line'>  <span class="p">(</span><span class="nb">doto </span><span class="p">(</span><span class="nf">.getGraphics</span> <span class="nv">frame</span><span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">.setColor</span> <span class="nv">Color/WHITE</span><span class="p">)))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="kd">defn </span><span class="nv">triangle</span> <span class="p">[</span><span class="nv">p1</span> <span class="nv">p2</span> <span class="nv">p3</span> <span class="nv">t-type</span><span class="p">]</span>
</span><span class='line'>  <span class="s">&quot;Takes three points p1, p2, and p3 and returns</span>
</span><span class='line'><span class="s">   a triangle map of type t-type. t-type is used</span>
</span><span class='line'><span class="s">   to specify the ordering/labeling of the input</span>
</span><span class='line'><span class="s">   coordinates:</span>
</span><span class='line'>
</span><span class='line'><span class="s">   :outer {:top p1 :b-left p2 :b-right p3}</span>
</span><span class='line'><span class="s">   :inner {:t-left p1 :t-right p2 :bottom p3}&quot;</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">condp</span> <span class="nb">= </span><span class="nv">t-type</span>
</span><span class='line'>    <span class="ss">:outer</span> <span class="p">{</span><span class="ss">:top</span> <span class="nv">p1</span> <span class="ss">:b-left</span> <span class="nv">p2</span> <span class="ss">:b-right</span> <span class="nv">p3</span><span class="p">}</span>
</span><span class='line'>    <span class="ss">:inner</span> <span class="p">{</span><span class="ss">:t-left</span> <span class="nv">p1</span> <span class="ss">:t-right</span> <span class="nv">p2</span> <span class="ss">:bottom</span> <span class="nv">p3</span><span class="p">}))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="kd">defn </span><span class="nv">inner</span> <span class="p">[</span><span class="nv">t</span><span class="p">]</span>
</span><span class='line'>  <span class="s">&quot;Takes an :outer triangle t and returns a map of</span>
</span><span class='line'><span class="s">   coordinates for its inner (inverse) triangle.&quot;</span>
</span><span class='line'>  <span class="p">(</span><span class="k">let </span><span class="p">[{</span><span class="ss">:keys</span> <span class="p">[</span><span class="nv">top</span> <span class="nv">b-left</span> <span class="nv">b-right</span><span class="p">]}</span> <span class="nv">t</span>
</span><span class='line'>        <span class="p">[</span><span class="nv">x1</span> <span class="nv">y1</span><span class="p">]</span> <span class="nv">top</span>
</span><span class='line'>        <span class="p">[</span><span class="nv">x2</span> <span class="nv">y2</span><span class="p">]</span> <span class="nv">b-left</span>
</span><span class='line'>        <span class="p">[</span><span class="nv">x3</span> <span class="nv">y3</span><span class="p">]</span> <span class="nv">b-right</span><span class="p">]</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">triangle</span> <span class="p">(</span><span class="nb">map double </span><span class="p">[(</span><span class="nb">+ </span><span class="nv">x2</span> <span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nb">- </span><span class="nv">x1</span> <span class="nv">x2</span><span class="p">)</span> <span class="mi">2</span><span class="p">))</span>
</span><span class='line'>                           <span class="p">(</span><span class="nb">+ </span><span class="nv">y1</span> <span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nb">- </span><span class="nv">y2</span> <span class="nv">y1</span><span class="p">)</span> <span class="mi">2</span><span class="p">))])</span>
</span><span class='line'>              <span class="p">(</span><span class="nb">map double </span><span class="p">[(</span><span class="nb">+ </span><span class="nv">x1</span> <span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nb">- </span><span class="nv">x3</span> <span class="nv">x1</span><span class="p">)</span> <span class="mi">2</span><span class="p">))</span>
</span><span class='line'>                           <span class="p">(</span><span class="nb">+ </span><span class="nv">y1</span> <span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nb">- </span><span class="nv">y3</span> <span class="nv">y1</span><span class="p">)</span> <span class="mi">2</span><span class="p">))])</span>
</span><span class='line'>              <span class="p">(</span><span class="nb">map double </span><span class="p">[(</span><span class="nb">+ </span><span class="nv">x2</span> <span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nb">- </span><span class="nv">x3</span> <span class="nv">x2</span><span class="p">)</span> <span class="mi">2</span><span class="p">))</span>
</span><span class='line'>                           <span class="p">(</span><span class="nb">/ </span><span class="p">(</span><span class="nb">+ </span><span class="nv">y2</span> <span class="nv">y3</span><span class="p">)</span> <span class="mi">2</span><span class="p">)])</span> <span class="ss">:inner</span><span class="p">)))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="kd">defn </span><span class="nv">outers</span> <span class="p">[</span><span class="nv">t</span><span class="p">]</span>
</span><span class='line'>  <span class="s">&quot;Takes an :outer triangle t and returns a map of triangle</span>
</span><span class='line'><span class="s">   maps labeled :top :b-left and :b-right that represent</span>
</span><span class='line'><span class="s">   the triangle&#39;s three outer triangles.&quot;</span>
</span><span class='line'>  <span class="p">(</span><span class="k">let </span><span class="p">[{[</span><span class="nv">x1</span> <span class="nv">y1</span><span class="p">]</span> <span class="ss">:top</span>
</span><span class='line'>         <span class="p">[</span><span class="nv">x2</span> <span class="nv">y2</span><span class="p">]</span> <span class="ss">:b-left</span>
</span><span class='line'>         <span class="p">[</span><span class="nv">x3</span> <span class="nv">y3</span><span class="p">]</span> <span class="ss">:b-right</span><span class="p">}</span> <span class="nv">t</span>
</span><span class='line'>        <span class="p">{[</span><span class="nv">ix1</span> <span class="nv">iy1</span><span class="p">]</span> <span class="ss">:t-left</span>
</span><span class='line'>         <span class="p">[</span><span class="nv">ix2</span> <span class="nv">iy2</span><span class="p">]</span> <span class="ss">:t-right</span>
</span><span class='line'>         <span class="p">[</span><span class="nv">ix3</span> <span class="nv">iy3</span><span class="p">]</span> <span class="ss">:bottom</span><span class="p">}</span> <span class="p">(</span><span class="nf">inner</span> <span class="nv">t</span><span class="p">)]</span>
</span><span class='line'>    <span class="p">{</span><span class="ss">:top</span> <span class="p">(</span><span class="nf">triangle</span> <span class="p">[</span><span class="nv">x1</span> <span class="nv">y1</span><span class="p">]</span> <span class="p">[</span><span class="nv">ix1</span> <span class="nv">iy1</span><span class="p">]</span> <span class="p">[</span><span class="nv">ix2</span> <span class="nv">iy2</span><span class="p">]</span> <span class="ss">:outer</span><span class="p">)</span>
</span><span class='line'>     <span class="ss">:b-left</span> <span class="p">(</span><span class="nf">triangle</span> <span class="p">[</span><span class="nv">ix1</span> <span class="nv">iy1</span><span class="p">]</span> <span class="p">[</span><span class="nv">x2</span> <span class="nv">y2</span><span class="p">]</span> <span class="p">[</span><span class="nv">ix3</span> <span class="nv">iy3</span><span class="p">]</span> <span class="ss">:outer</span><span class="p">)</span>
</span><span class='line'>     <span class="ss">:b-right</span> <span class="p">(</span><span class="nf">triangle</span> <span class="p">[</span><span class="nv">ix2</span> <span class="nv">iy2</span><span class="p">]</span> <span class="p">[</span><span class="nv">ix3</span> <span class="nv">iy3</span><span class="p">]</span> <span class="p">[</span><span class="nv">x3</span> <span class="nv">y3</span><span class="p">]</span> <span class="ss">:outer</span><span class="p">)}))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="kd">defn </span><span class="nv">draw-triangle</span> <span class="p">[</span><span class="nv">t</span><span class="p">]</span>
</span><span class='line'>  <span class="s">&quot;Takes a triangle t and draws it.&quot;</span>
</span><span class='line'>  <span class="p">(</span><span class="k">let </span><span class="p">[[[</span><span class="nv">x1</span> <span class="nv">y1</span><span class="p">]</span>
</span><span class='line'>         <span class="p">[</span><span class="nv">x2</span> <span class="nv">y2</span><span class="p">]</span>
</span><span class='line'>         <span class="p">[</span><span class="nv">x3</span> <span class="nv">y3</span><span class="p">]]</span> <span class="p">(</span><span class="nb">vals </span><span class="nv">t</span><span class="p">)]</span>
</span><span class='line'>    <span class="p">(</span><span class="nf">do</span>
</span><span class='line'>      <span class="p">(</span><span class="nf">.drawLine</span> <span class="nv">gfx</span> <span class="nv">x1</span> <span class="nv">y1</span> <span class="nv">x2</span> <span class="nv">y2</span><span class="p">)</span>
</span><span class='line'>      <span class="p">(</span><span class="nf">.drawLine</span> <span class="nv">gfx</span> <span class="nv">x1</span> <span class="nv">y1</span> <span class="nv">x3</span> <span class="nv">y3</span><span class="p">)</span>
</span><span class='line'>      <span class="p">(</span><span class="nf">.drawLine</span> <span class="nv">gfx</span> <span class="nv">x2</span> <span class="nv">y2</span> <span class="nv">x3</span> <span class="nv">y3</span><span class="p">))))</span>
</span><span class='line'>
</span><span class='line'><span class="c1">;; Entry method</span>
</span><span class='line'><span class="p">(</span><span class="kd">defn </span><span class="nv">sierpinski</span>
</span><span class='line'>  <span class="p">([]</span>
</span><span class='line'>     <span class="p">(</span><span class="nf">sierpinski</span> <span class="mi">10</span><span class="p">))</span>
</span><span class='line'>  <span class="p">([</span><span class="nv">lvl</span><span class="p">]</span> <span class="p">(</span><span class="nf">sierpinski</span> <span class="p">(</span><span class="nf">triangle</span> <span class="p">[</span><span class="mi">250</span> <span class="mi">75</span><span class="p">]</span> <span class="p">[</span><span class="mi">25</span> <span class="mi">450</span><span class="p">]</span> <span class="p">[</span><span class="mi">475</span> <span class="mi">450</span><span class="p">]</span> <span class="ss">:outer</span><span class="p">)</span> <span class="nv">lvl</span> <span class="nv">true</span><span class="p">))</span>
</span><span class='line'>  <span class="p">([</span><span class="nv">t</span> <span class="nv">lvl</span><span class="p">]</span>
</span><span class='line'>     <span class="p">(</span><span class="nb">when </span><span class="p">(</span><span class="nb">&gt; </span><span class="nv">lvl</span> <span class="mi">0</span><span class="p">)</span>
</span><span class='line'>       <span class="p">(</span><span class="nf">draw-triangle</span> <span class="p">(</span><span class="nf">inner</span> <span class="nv">t</span><span class="p">))</span>
</span><span class='line'>       <span class="p">(</span><span class="nb">doseq </span><span class="p">[</span><span class="nv">sub-t</span> <span class="p">(</span><span class="nb">vals </span><span class="p">(</span><span class="nf">outers</span> <span class="nv">t</span><span class="p">))]</span>
</span><span class='line'>         <span class="p">(</span><span class="nf">sierpinski</span> <span class="nv">sub-t</span> <span class="p">(</span><span class="nb">dec </span><span class="nv">lvl</span><span class="p">)))))</span>
</span><span class='line'>  <span class="p">([</span><span class="nv">t</span> <span class="nv">lvl</span> <span class="nv">first?</span><span class="p">]</span>
</span><span class='line'>     <span class="p">(</span><span class="k">if </span><span class="nv">first?</span>
</span><span class='line'>       <span class="p">(</span><span class="k">do </span>
</span><span class='line'>         <span class="p">(</span><span class="nf">draw-triangle</span> <span class="nv">t</span><span class="p">)</span>
</span><span class='line'>         <span class="p">(</span><span class="nf">sierpinski</span> <span class="nv">t</span> <span class="nv">lvl</span> <span class="nv">false</span><span class="p">))</span>
</span><span class='line'>       <span class="p">(</span><span class="nf">sierpinski</span> <span class="nv">t</span> <span class="nv">lvl</span><span class="p">))))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="kd">defn </span><span class="nv">clear</span> <span class="p">[</span><span class="nv">gfx</span><span class="p">]</span>
</span><span class='line'>  <span class="s">&quot;Clears the Graphics2D context&quot;</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">.clearRect</span> <span class="nv">gfx</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">500</span> <span class="mi">500</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="kd">defn </span><span class="nv">save</span> <span class="p">[</span><span class="nv">lvl</span> <span class="nv">path</span><span class="p">]</span>
</span><span class='line'>  <span class="s">&quot;Binds gfx to the Graphics context of a new</span>
</span><span class='line'><span class="s">   BufferedImage, calls sierpinski to draw on it,</span>
</span><span class='line'><span class="s">   and then writes the BufferedImage contents to a</span>
</span><span class='line'><span class="s">   png file at path.&quot;</span>
</span><span class='line'>  <span class="p">(</span><span class="k">let </span><span class="p">[</span><span class="nv">c</span> <span class="p">(</span><span class="nf">.getContentPane</span> <span class="nv">frame</span><span class="p">)</span>
</span><span class='line'>        <span class="nv">bi</span> <span class="p">(</span><span class="nf">BufferedImage.</span> <span class="p">(</span><span class="nf">.getWidth</span> <span class="nv">c</span><span class="p">)</span> <span class="p">(</span><span class="nf">.getHeight</span> <span class="nv">c</span><span class="p">)</span> <span class="nv">BufferedImage/TYPE_INT_RGB</span><span class="p">)</span>
</span><span class='line'>        <span class="nv">new-gfx</span> <span class="p">(</span><span class="nf">.createGraphics</span> <span class="nv">bi</span><span class="p">)]</span>
</span><span class='line'>    <span class="p">(</span><span class="nb">binding </span><span class="p">[</span><span class="nv">gfx</span> <span class="nv">new-gfx</span><span class="p">]</span>
</span><span class='line'>      <span class="p">(</span><span class="nf">clear</span> <span class="nv">gfx</span><span class="p">)</span>
</span><span class='line'>      <span class="p">(</span><span class="nf">sierpinski</span> <span class="nv">lvl</span><span class="p">)</span>
</span><span class='line'>      <span class="p">(</span><span class="nf">ImageIO/write</span> <span class="nv">bi</span> <span class="s">&quot;PNG&quot;</span> <span class="p">(</span><span class="nf">java.io.File.</span> <span class="nv">path</span><span class="p">)))))</span>
</span><span class='line'>
</span><span class='line'><span class="p">(</span><span class="kd">defn </span><span class="nv">-main</span> <span class="p">[</span><span class="o">&amp;</span> <span class="nv">args</span><span class="p">]</span>
</span><span class='line'>  <span class="s">&quot;Main method&quot;</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">clear</span> <span class="nv">gfx</span><span class="p">)</span>
</span><span class='line'>  <span class="p">(</span><span class="nf">sierpinski</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>You can suck that into your REPL and run it:</p>

<p>``` clojure
(load-file &ldquo;/path/to/sierpinski.clj&rdquo;)
;;&ndash;> nil</p>

<p>(ns sierpinski)
;;&ndash;> nil</p>

<p>(-main)
;;&ndash;> nil
```</p>

<p>Or just run this from the same directory as the script:</p>

<p><code>bash
java -cp .:/path/to/clojure.jar clojure.main -m sierpinski sierpinski.clj
</code></p>

<p>You should see this output:</p>

<p><img src="/images/posts/sierpinski_triangle_fractal/sierpinski_10.png"></p>

<p>P.S. You can call <code>save</code> with a level and a supplied path string to
save an image for the corresponding Sierpinski triangle (it needs to
repaint it to a new graphics context).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Dynamic Binding and Being Meta]]></title>
    <link href="http://rxacevedo.github.io/blog/2014/02/07/dynamic-binding-and-being-meta/"/>
    <updated>2014-02-07T17:47:38-05:00</updated>
    <id>http://rxacevedo.github.io/blog/2014/02/07/dynamic-binding-and-being-meta</id>
    <content type="html"><![CDATA[<p>Yesterday at work I had the perverse urge to send an email to someone
that contained the code used to generate the email itself. The concept
is relatively similar to the below (initially incorrect) example:</p>

<p><code>clojure
(let [a '(println (str "Printing myself: " a))]
  (eval a))
;;-&gt; Printing myself: Unbound: #'user/a
;;-&gt; nil
</code>
Clearly this doesn&rsquo;t work, but I would like to explore why exactly that is.
First though, we should discuss how Clojure (and Lisps in general)
treat and evaluate functions. When we call a function, we do it in
this way:</p>

<p><code>clojure
(inc 1)
;;-&gt; 2
</code></p>

<p>This is just a list of symbols; the Clojure reader will recognize
this list as a call because:</p>

<ol>
<li>It is not empty.</li>
<li>It is not quoted.</li>
</ol>


<p>The first item in the list is assumed to be a special form, a macro,
or a function. This is why this works:</p>

<p><code>clojure
(+ 1 2 3 4 5)
;;-&gt; 15
</code></p>

<p>But this does not:</p>

<p><code>clojure
(1 2 3 4 5)
;;-&gt; ClassCastException java.lang.Long cannot be cast to
;;-&gt; clojure.lang.IFn  user/eval12732 (form-init6247023468986614197.clj:1)
</code></p>

<p>The exception message sums it up nicely, 1 is not a function and therefore
cannot be called, so we get an error. Many times though, we will want
to create a list and not have it evaluated. We do this by quoting the
list, either with the <code>quote</code> function or using a quote literal <code>'</code>.</p>

<p>``` clojure
&lsquo;(1 2 3 4 5)
;;&ndash;> (1 2 3 4 5)</p>

<p>&lsquo;(a list of words and stuff)
;;&ndash;> (a list of words and stuff)</p>

<p>(quote (0 1 1 2 3))
;;&ndash;> (0 1 1 2 3)</p>

<p>(quote (here have more words))
;;&ndash;> (here have more words)
```</p>

<p>There&rsquo;s no difference between a quoted list and an unquoted
list aside from the fact that one is evaluated and one is not.
Likewise, there&rsquo;s no difference between the symbols in a list aside
from how they are treated, which depends on whether or not the list is
evaluted.</p>

<p>``` clojure
&lsquo;(println (str &ldquo;This is also&rdquo; &ldquo; a list of symbols!&rdquo;))
;;&ndash;> (println (str &ldquo;This is also&rdquo; &ldquo; a list of symbols!&rdquo;))
;;&ndash;> nil</p>

<p>(println (str &ldquo;This is also&rdquo; &ldquo; a list of symbols!&rdquo;))
;;&ndash;> This is also a list of symbols!
;;&ndash;> nil
```</p>

<p>If we want to evaluate a list, we can use the <code>eval</code> function:</p>

<p><code>clojure
(eval '(take 10 (iterate inc 0)))
;;-&gt; (0 1 2 3 4 5 6 7 8 9)
</code></p>

<p>Going back to the example above:</p>

<p><code>clojure
(let [a '(println (str "Printing myself: " a))]
  (eval a))
;;-&gt; Printing myself: Unbound: #'user/a
;;-&gt; nil
</code></p>

<p>This doesn&rsquo;t work because the <code>let</code> binding is lexically scoped,
meaning that anything declared in the let is bound/accessible only in
that scope, or the immediate textual region. The <code>eval</code> function,
however, evaluates forms in a
<a href="http://www.ai.mit.edu/projects/iiip/doc/CommonLISP/HyperSpec/Body/glo_n.html#null_lexical_environment">null lexical environment</a>,
so it cannot see our binding on <code>a</code>. That is why when we evaluate the
s-expression using <code>eval</code>, we cannot access the binding on the Var &ndash; it
is outside of our scope. By that same token, that is why we can have
nested <code>let</code>s:</p>

<p>``` clojure
(let [a &ldquo;YOLO&rdquo;]
  (let [b &ldquo;Don&rsquo;t kill my vibe&rdquo;]</p>

<pre><code>(let [c "I'm my own woman"]
  (let [d "Go fit or go home"]
    (println (str "Instagram in a nutshell: \n" 
                  (clojure.string/join "\n" [a b c d])))))))
</code></pre>

<p>;;&ndash;> Instagram in a nutshell:
;;&ndash;> YOLO
;;&ndash;> Don&rsquo;t kill my vibe
;;&ndash;> I&rsquo;m my own woman
;;&ndash;> Go fit or go home
;;&ndash;> nil                    <br/>
<code>``
Each subsequent</code>let<code>is enclosed within the outer</code>let<code>, in which the
call to</code>println` is evaluated. This is exactly what a closure is:</p>

<p><code>clojure
(def a "Hey I'm a Var and I'm accessible throughout this entire namespace!")
;;-&gt; #'user/a
(let [a "But not when we're in a lexical closure, ha!"]
  a)
;;-&gt; "But not when we're in a lexical closure, ha!"
</code></p>

<p>To get around this scope issue, we need to ensure that the Var we are trying
to access can be resolved outside of the lexical scope of the call to
<code>eval</code>. We can do this by either:</p>

<ol>
<li>Using <code>def</code> to declare the Var and bind a value to it.</li>
<li>Using <code>declare</code> to declare the Var without a binding, and then use
<code>binding</code> to bind a value to it.</li>
</ol>


<p>Whichever way we do it, we need to ensure that the Var is dynamically
accessible, or all of our work will be for naught. This is done by
declaring or defining the Var with dynamic <strong>metadata</strong>:</p>

<p>``` clojure
(do
  (declare ^:dynamic a)
  (binding [a &lsquo;(println (str &ldquo;Printing myself: &rdquo; a))]</p>

<pre><code>(eval a)))
</code></pre>

<p> ;;&ndash;> Printing myself: (println (str &ldquo;Printing myself: &rdquo; a))
 ;;&ndash;> nil
```</p>

<p>That&rsquo;s the ticket! Now we can be super cool/meta programmer kidz (if
you have the amazazazing
<a href="https://github.com/cemerick/pomegranate">pomegranate by Chas Emerick</a> on your classpath):</p>

<p>``` clojure
(require &lsquo;[cemerick.pomegranate :refer :all])
;;&ndash;> nil</p>

<p>(add-dependencies :coordinates &lsquo;[[com.draines/postal &ldquo;1.11.1&rdquo;]]</p>

<pre><code>              :repositories {"clojars" "http://clojars.org/repo"})
</code></pre>

<p>;;&ndash;> {[javax.mail/mail &ldquo;1.4.4&rdquo; :exclusions [[javax.activation/activation]]] nil,
;;&ndash;>  [commons-codec &ldquo;1.7&rdquo;] nil,
;;&ndash;>  [com.draines/postal &ldquo;1.11.1&rdquo;]
;;&ndash;>  #{[javax.mail/mail &ldquo;1.4.4&rdquo; :exclusions [[javax.activation/activation]]] [commons-codec &ldquo;1.7&rdquo;]}}</p>

<p>(require &lsquo;[postal [core :as postal]])
;;&ndash;> nil</p>

<p>(do
  (declare ^:dynamic codez)</p>

<pre><code>(binding [codez '(postal/send-message ^{:host "smtp.neatwebsite.com"
                                        :user "brogrammer@neatwebsite.com"
                                        :pass "sekr3t!"
                                        :ssl :damn-right!}
                                      {:from "A really cool dude"
                                       :to "you@yoursite.com"
                                       :subject "Incoming: super meta email"
                                       :body (str "Czech it out bby, this code generated this email: \n\n" 
                                                   (binding [*out* (java.io.StringWriter.)]
                                                     (pprint codez)
                                                     (.toString *out*)))})]
  (eval codez)))
</code></pre>

<p>;;&ndash;> {:error :SUCCESS, :code 0, :message &ldquo;messages sent&rdquo;}
```</p>

<p>Awesome! That generates an email that looks like this:</p>

<p>``` text
Czech it out bby, this code generated this email:</p>

<p>(postal/send-message
{:from &ldquo;A really cool dude&rdquo;,
 :to &ldquo;<a href="&#x6d;&#x61;&#x69;&#x6c;&#116;&#x6f;&#x3a;&#121;&#x6f;&#117;&#64;&#x79;&#111;&#x75;&#x72;&#x73;&#105;&#x74;&#101;&#x2e;&#99;&#111;&#109;">&#x79;&#x6f;&#117;&#x40;&#x79;&#111;&#117;&#114;&#115;&#x69;&#x74;&#x65;&#46;&#99;&#111;&#109;</a>&rdquo;,
 :subject &ldquo;Incoming: super meta email&rdquo;,
 :body
 (str
 &ldquo;Czech it out bby, this code generated this email: \n\n&rdquo;
 (binding
 [<em>out</em> (java.io.StringWriter.)]
 (pprint codez)
 (.toString <em>out</em>)))})
```
Don&rsquo;t you feel a billion times cooler now?</p>
]]></content>
  </entry>
  
</feed>
