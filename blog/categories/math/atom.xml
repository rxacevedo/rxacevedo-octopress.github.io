<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Math | Roberto Acevedo]]></title>
  <link href="http://rxacevedo.github.io/blog/categories/math/atom.xml" rel="self"/>
  <link href="http://rxacevedo.github.io/"/>
  <updated>2014-02-10T06:20:03-05:00</updated>
  <id>http://rxacevedo.github.io/</id>
  <author>
    <name><![CDATA[Roberto Acevedo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Approximating the Golden Ratio]]></title>
    <link href="http://rxacevedo.github.io/blog/2014/02/09/approximating-the-golden-ratio/"/>
    <updated>2014-02-09T12:47:20-05:00</updated>
    <id>http://rxacevedo.github.io/blog/2014/02/09/approximating-the-golden-ratio</id>
    <content type="html"><![CDATA[<p>This will be short post, inspired by a problem I encountered while
working through chapter 3 of
<a href="https://gustavus.edu/+max/concrete-abstractions.html">Concrete Abstractions</a>
a few months back. We are tasked with writing a procedure that
approximates the Golden Ratio within a certain tolerance. Recall that
the Golden Ratio is defined as:</p>

<p><code>text
a/b = (a + b)/a
</code></p>

<p>With a little math, we can restate this as a recurrence relation,
which provides the key for writing our procedure:</p>

<p>``` text
Φ = a/b</p>

<p>a/b = (a + b)/a</p>

<pre><code>= a/a + b/a
= 1 + b/a
= 1 + 1/(a/b)
</code></pre>

<p>a/b = 1 + 1/(a/b)</p>

<p>Φ = 1 + 1/Φ
```</p>

<p>Now that we can state the Golden Ratio as a function of itself, we can
write a procedure that will approxiate it within a certain tolerance.
To know when to stop, we are given a valuable piece of information:
the error of each approximation is less than 1 over the square of its
denominator. This means that we can stop <code>recur</code>ring when 1/(b*b) is
less than our acceptable tolerance. Our final function can be set up
as:</p>

<p>``` clojure
(defn approximate-golden-ratio [tolerance]
  (let [improve (fn [guess]</p>

<pre><code>              (+ 1 (/ 1 guess)))]
(loop [start 1]
  (let [d (if (= clojure.lang.Ratio (type start))
            (denominator start)
            1)]
    (if (&gt; tolerance (/ 1 (* d d)))
      start
      (recur (improve start)))))))
</code></pre>

<p>```</p>

<p>The above check on the type of our start argument is necessary because
in Clojure, 1/1 evaluates to 1 immediately, so calling <code>denominator</code>
on it will throw a <code>ClassCastException</code> right off the bat. I could not
find a way around this issue, not even with quoting:</p>

<p>``` clojure
&lsquo;1/1
;;&ndash;> 1</p>

<p>&lsquo;(1/1)
;;&ndash;> (1)
```</p>

<p>Now with our function in place, we can approximate the Golden Ratio:</p>

<p>``` clojure
(approximate-golden-ratio 1/50000)
;;&ndash;> 377/233</p>

<p>(double (approximate-golden-ratio 1/50000))
;;&ndash;> 1.618025751072961
```</p>

<p>While we&rsquo;re here, I&rsquo;d like to demonstrate something about the Golden
Ratio that is pretty neat: each approximation (using this method of
rational approximations) is a <strong>ratio of successive Fibonacci
numbers</strong>. Let&rsquo;s modify our function to print these ratios as it
loops:</p>

<p>``` clojure
(defn approximate-golden-ratio [tolerance]
  (let [improve (fn [guess]</p>

<pre><code>              (+ 1 (/ 1 guess)))]
(loop [start 1]
  (println (str "Current guess: " start))
  (let [d (if (= clojure.lang.Ratio (type start))
            (denominator start)
            1)]
    (if (&gt; tolerance (/ 1 (* d d)))
      start
      (recur (improve start)))))))
</code></pre>

<p>```</p>

<p>Now when we call it, we will see the successive Fibonacci numbers:</p>

<p><code>clojure
(approximate-golden-ratio 1/50000)
;;-&gt; Current guess: 1
;;-&gt; Current guess: 2
;;-&gt; Current guess: 3/2
;;-&gt; Current guess: 5/3
;;-&gt; Current guess: 8/5
;;-&gt; Current guess: 13/8
;;-&gt; Current guess: 21/13
;;-&gt; Current guess: 34/21
;;-&gt; Current guess: 55/34
;;-&gt; Current guess: 89/55
;;-&gt; Current guess: 144/89
;;-&gt; Current guess: 233/144
;;-&gt; Current guess: 377/233
;;-&gt; 377/233
</code></p>

<p>Boy, those numbers sure look familiar!</p>

<p>``` clojure
(def fibs (lazy-cat [0 1] (map + fibs (rest fibs))))
;;&ndash;> nil</p>

<p>(take 15 fibs)
;;&ndash;> (0 1 1 2 3 5 8 13 21 34 55 89 144 233 377)
```</p>

<p>Neat stuff.</p>
]]></content>
  </entry>
  
</feed>
