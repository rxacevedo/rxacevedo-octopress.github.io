<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: scala | Roberto Acevedo]]></title>
  <link href="http://rxacevedo.github.io/blog/categories/scala/atom.xml" rel="self"/>
  <link href="http://rxacevedo.github.io/"/>
  <updated>2014-05-04T11:31:41-04:00</updated>
  <id>http://rxacevedo.github.io/</id>
  <author>
    <name><![CDATA[Roberto Acevedo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[First-class Functions]]></title>
    <link href="http://rxacevedo.github.io/blog/2014/01/07/first-class-functions/"/>
    <updated>2014-01-07T19:25:44-05:00</updated>
    <id>http://rxacevedo.github.io/blog/2014/01/07/first-class-functions</id>
    <content type="html"><![CDATA[<p>Functions that take functions as arguments and functions that return functions
as their results can be a somewhat tricky concept to grasp coming from a
purely object-oriented style of programming. I will say up front that higher-order
functions are mostly useful for list-processing, but we will soon see
that this enables us to affect changes on data (or data structures) without
actually modifying state, which comes in quite handy when writing threaded code.</p>

<p><code>clojure Le map
map
;; #&lt;core$map clojure.core$map@17448423&gt;
</code></p>

<p>Map? That&rsquo;s it? Yes, map is a function that takes a function and a number of
collections and will apply that function in one of two ways</p>

<ol>
<li>To each element of the collection &ndash; f(element)</li>
<li>To the group of elements that are at equal positions in the collections &ndash;
f(element1, element2, element3)</li>
</ol>


<p>One can easily observe the usefulness of higher-order functions (or HOFs) in this sense.
Here is a contrived example of mapping an anonymous function:</p>

<p>``` clojure Our first HOF
(map #(assoc % :cry (condp = (:type %)</p>

<pre><code>                  :cat "Meow"
                  :dog "Woof"
                  "HELP"))
 [{:name "Spot" :type :dog} 
  {:name "Whiskers" :type :cat}                                     
  {:name "Leila" :type :dog} 
  {:name "Geronimo" :type :cat}
  {:name "Izolda the Russian mail-order bride"}])
</code></pre>

<p>;; ({:cry &ldquo;Woof&rdquo;, :name &ldquo;Spot&rdquo;, :type :dog}
;;  {:cry &ldquo;Meow&rdquo;, :name &ldquo;Whiskers&rdquo;, :type :cat}
;;  {:cry &ldquo;Woof&rdquo;, :name &ldquo;Leila&rdquo;, :type :dog}
;;  {:cry &ldquo;Meow&rdquo;, :name &ldquo;Geronimo&rdquo;, :type :cat}
;;  {:cry &ldquo;HELP&rdquo;, :name &ldquo;Izolda the Russian mail-order bride&rdquo;})
```</p>

<p><em>Ok, we get it Roberto, there are some neat functions available in Scala and
Clojure that let us pass functions in, but why would we ever want to write our
own?</em></p>

<p>We need to think about our functions not just in terms of what they do, but how
they do it, the order that it&rsquo;s done in, and the types returned by each function
application. Let&rsquo;s write a function to obfuscate text as an example:</p>

<p>``` clojure Not so HOF
(defn obfuscate [text]
  (clojure.string/join (interleave (rest (iterate rand-int 42))</p>

<pre><code>(reverse (seq text)))))
</code></pre>

<p>```</p>

<p>Or, using a threading macro for clarity (hey, some people don&rsquo;t like
the parentheses):</p>

<p>``` clojure Still not so HOF
(defn obfuscate [text]
  (&ndash;>> text</p>

<pre><code>    seq
    reverse
    (interleave (rest (iterate rand-int 42)))
    clojure.string/join))
</code></pre>

<p>```</p>

<p>There are some components to this function that we would like to keep, i.e. the
call to seq to convert the string into a list of chars. But what about about the
call to reverse? We could easily omit this or replace it with another function.
We might also want to join the string back together using a character, and we
might not want to interleave with numbers, but rather with symbols. How could
we do this? We can remove these components and replace them with variables, and
then pass functions in that will be bound to those variables.</p>

<p>``` clojure A higher-order function that takes a String and returns a function
(defn make-obfuscator [text]
  (ƒ [f g h]</p>

<pre><code>  (f (g (h (seq text))))))
</code></pre>

<p>```</p>

<p>There are a variety of ways that one can achieve this in Scala, I am using function
currying here (each function takes a single parameter).</p>

<p><code>scala A higher-order function that takes a String and returns a function
def makeObfuscator(f: String =&gt; List[Char])(g: List[Char] =&gt; String)(s:String) = {
  val lambda = (a: String) =&gt; g(f(a))
  lambda(s)
}
</code></p>

<p>We can call this function and directly pass in the functions that we want like
this:</p>

<p><code>clojure Passing functions as arguments
((make-obfuscator clojure.string/join #(interleave (rest (iterate rand-int 42))
%) reverse) "Hello")
;; "12o7l2l1e0H"
</code></p>

<p>We can also harness the power of this higher-order function now, to define
multiple obfuscation functions (note: these are just examples, they are not meant to provide any sort of security):</p>

<p>``` clojure MOAR OBFUSCATORS!
(defn scramble [text]
  ((make-obfuscator clojure.string/join #(interleave (rest (iterate rand-int 42)) %) reverse) text))</p>

<p>(defn jumble [text]
  ((make-obfuscator #(clojure.string/join &ldquo;_&rdquo; %) #(shuffle (seq %)) clojure.string/upper-case) text))</p>

<p>(defn move-yo-chars-every-every-char [text]
  ((make-obfuscator #(apply str (shuffle %)) #(interleave (map char (iterate inc 33)) %) reverse) text))
```</p>

<p>Let&rsquo;s test that they work:</p>

<p>``` clojure I&rsquo;m writing stuff
(scramble &ldquo;Moriturus te saluto.&rdquo;)
;; &ldquo;27.11o1t0u0l0a0s0 0e0t0 0s0u0r0u0t0i0r0o0M&rdquo;</p>

<p>(jumble &ldquo;Moriturus te saluto.&rdquo;)
;; &ldquo;S<em> _ </em>\<em>\</em>P_P<em> </em>\<em>C</em> _ <em>E</em> <em>E</em> _ <em>\</em> <em>U</em> <em>S_A</em>)<em> </em>.<em>\</em>\<em>R</em>\<em>U</em>\<em>L__S</em>\<em>\</em>O_A<em>\</em> _ <em>\</em> <em>E_R</em> <em>O_C</em>\<em>T</em>\<em>T_T</em>\<em>\</em>U<em> </em>\<em>I</em>(<em>S</em>\<em>\</em>M_A_\__ &rdquo;</p>

<p>(move-yo-chars-every-every-char &ldquo;Moriturus te saluto.&rdquo;)
;; &ldquo;a1t # $o2ie30%.u)sr!*&ndash;,tu&amp;.Mu/t4o'\"r(sl+&rdquo;
```
As you can see, higher-order functions can be used to generate many new
functions that share a common behavior pattern.</p>

<p>Here is less complex version in Scala that uses case classes to switch on message
types:</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><figcaption><span> (Obfuscate.scala)</span> <a href='/downloads/code/scala/Obfuscate.scala'>download</a></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">object</span> <span class="nc">Obfuscate</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">case</span> <span class="k">class</span> <span class="nc">WikiLeaks</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="k">class</span> <span class="nc">NSA</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="k">class</span> <span class="nc">InstantMessage</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="k">class</span> <span class="nc">Password</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">main</span><span class="o">(</span><span class="n">args</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">])</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">println</span><span class="o">(</span><span class="n">scramble</span><span class="o">(</span><span class="s">&quot;Hello!&quot;</span><span class="o">))</span>
</span><span class='line'>    <span class="n">println</span><span class="o">(</span><span class="n">jumble</span><span class="o">(</span><span class="s">&quot;Moriturus te saluto.&quot;</span><span class="o">))</span>
</span><span class='line'>    <span class="n">println</span><span class="o">(</span><span class="n">mungeString</span><span class="o">(</span><span class="s">&quot;I&#39;m typing words&quot;</span><span class="o">))</span>
</span><span class='line'>    <span class="n">println</span><span class="o">(</span><span class="s">&quot;Case classes\n&quot;</span><span class="o">)</span>
</span><span class='line'>    <span class="k">val</span> <span class="o">(</span><span class="n">wklks</span><span class="o">,</span> <span class="n">nsa</span><span class="o">,</span> <span class="n">im</span><span class="o">,</span> <span class="n">pw</span><span class="o">)</span> <span class="k">=</span> <span class="o">(</span><span class="nc">WikiLeaks</span><span class="o">(</span><span class="s">&quot;Julian Assange&quot;</span><span class="o">),</span> <span class="c1">// This is a tuple</span>
</span><span class='line'>                                <span class="nc">NSA</span><span class="o">(</span><span class="s">&quot;Edward Snowden&quot;</span><span class="o">),</span>
</span><span class='line'>                                <span class="nc">InstantMessage</span><span class="o">(</span><span class="s">&quot;OMG GUESS WHO SAID WHAT&quot;</span><span class="o">),</span>
</span><span class='line'>                                <span class="nc">Password</span><span class="o">(</span><span class="s">&quot;puppyKisses123&quot;</span><span class="o">))</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">println</span><span class="o">(</span><span class="s">&quot;The secrets are: \n&quot;</span> <span class="o">+</span>
</span><span class='line'>      <span class="n">dispatch</span><span class="o">(</span><span class="n">wklks</span><span class="o">)</span> <span class="o">+</span>
</span><span class='line'>      <span class="s">&quot;\n&quot;</span> <span class="o">+</span>
</span><span class='line'>      <span class="n">dispatch</span><span class="o">(</span><span class="n">nsa</span><span class="o">)</span> <span class="o">+</span>
</span><span class='line'>      <span class="s">&quot;\n&quot;</span> <span class="o">+</span>
</span><span class='line'>      <span class="n">dispatch</span><span class="o">(</span><span class="n">im</span><span class="o">)</span> <span class="o">+</span>
</span><span class='line'>      <span class="s">&quot;\n&quot;</span> <span class="o">+</span> <span class="n">dispatch</span><span class="o">(</span><span class="n">pw</span><span class="o">))</span>
</span><span class='line'>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">dispatch</span><span class="o">(</span><span class="n">message</span><span class="k">:</span> <span class="kt">Any</span><span class="o">)</span><span class="k">=</span> <span class="n">message</span> <span class="k">match</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">case</span> <span class="nc">WikiLeaks</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">scramble</span><span class="o">(</span><span class="n">message</span><span class="o">.</span><span class="n">toString</span><span class="o">)</span>
</span><span class='line'>      <span class="k">case</span> <span class="nc">NSA</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">jumble</span><span class="o">(</span><span class="n">message</span><span class="o">.</span><span class="n">toString</span><span class="o">)</span>
</span><span class='line'>      <span class="k">case</span> <span class="nc">InstantMessage</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">mungeString</span><span class="o">(</span><span class="n">message</span><span class="o">.</span><span class="n">toString</span><span class="o">)</span>
</span><span class='line'>      <span class="k">case</span> <span class="nc">Password</span><span class="o">(</span><span class="n">s</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">scramble</span><span class="o">(</span><span class="n">jumble</span><span class="o">(</span><span class="n">scramble</span><span class="o">(</span><span class="n">message</span><span class="o">.</span><span class="n">toString</span><span class="o">)))</span>
</span><span class='line'>      <span class="k">case</span> <span class="k">_</span> <span class="k">=&gt;</span> <span class="s">&quot;None&quot;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// Old and boring</span>
</span><span class='line'>  <span class="c1">// def obfuscate(text: String): String = {</span>
</span><span class='line'>  <span class="c1">//   util.Random.shuffle(List.concat(text)).mkString</span>
</span><span class='line'>  <span class="c1">// }</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">makeObfuscator</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">])(</span><span class="n">g</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">]</span> <span class="k">=&gt;</span> <span class="nc">String</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="n">composed</span> <span class="k">=</span> <span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">g</span><span class="o">(</span><span class="n">f</span><span class="o">(</span><span class="n">a</span><span class="o">))</span>
</span><span class='line'>    <span class="n">composed</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">scramble</span><span class="o">(</span><span class="n">text</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="n">f</span> <span class="k">=</span> <span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">util</span><span class="o">.</span><span class="nc">Random</span><span class="o">.</span><span class="n">shuffle</span><span class="o">(</span><span class="nc">List</span><span class="o">.</span><span class="n">concat</span><span class="o">(</span><span class="n">a</span><span class="o">))</span>
</span><span class='line'>    <span class="k">val</span> <span class="n">g</span> <span class="k">=</span> <span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">])</span> <span class="k">=&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">mkString</span>
</span><span class='line'>    <span class="n">makeObfuscator</span><span class="o">(</span><span class="n">f</span><span class="o">)(</span><span class="n">g</span><span class="o">)(</span><span class="n">text</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">jumble</span><span class="o">(</span><span class="n">text</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="n">f</span> <span class="k">=</span> <span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">.</span><span class="n">concat</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</span><span class='line'>    <span class="k">val</span> <span class="n">g</span> <span class="k">=</span> <span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">])</span> <span class="k">=&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">mkString</span><span class="o">(</span><span class="s">&quot;:&gt;&gt;&quot;</span><span class="o">)</span>
</span><span class='line'>    <span class="n">makeObfuscator</span><span class="o">(</span><span class="n">f</span><span class="o">)(</span><span class="n">g</span><span class="o">)(</span><span class="n">text</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">mungeString</span><span class="o">(</span><span class="n">text</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="n">f</span> <span class="k">=</span> <span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">.</span><span class="n">concat</span><span class="o">(</span><span class="n">a</span><span class="o">)</span>
</span><span class='line'>    <span class="k">val</span> <span class="n">g</span> <span class="k">=</span> <span class="o">(</span><span class="n">a</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Char</span><span class="o">])</span> <span class="k">=&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">mkString</span><span class="o">(</span><span class="s">&quot;666&quot;</span><span class="o">)</span>
</span><span class='line'>    <span class="n">makeObfuscator</span><span class="o">(</span><span class="n">f</span><span class="o">)(</span><span class="n">g</span><span class="o">)(</span><span class="n">text</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scala and Clojure List Operations]]></title>
    <link href="http://rxacevedo.github.io/blog/2013/12/18/scala-and-clojure-list-operations/"/>
    <updated>2013-12-18T19:32:00-05:00</updated>
    <id>http://rxacevedo.github.io/blog/2013/12/18/scala-and-clojure-list-operations</id>
    <content type="html"><![CDATA[<p>Functional programming is an incredibly powerful paradigm that empowers developers to be more flexible in the ways that they devise and implement solutions to problems. One of the most powerful features of functional programming, regardless of language, is the manner in which it allows us to interact with data structures. Provided here are some examples of &ldquo;list functions&rdquo; in both Scala and Clojure:</p>

<h2>Creating a list:</h2>

<h4>Scala</h4>

<p><code>scala
List(1, 2, 3, 4, 5)
// res10: List[Int] = List(1, 2, 3, 4, 5)
</code></p>

<p>List() is a constructor, it takes varargs and returns an immutable list (scala.collection.immutable.List). If you want a mutable list, you should use an ArrayBuffer(scala.collection.mutable.ArrayBuffer).</p>

<h4>Clojure</h4>

<p><code>clojure
'(1 2 3 4 5)
;; (1 2 3 4 5)
</code></p>

<p>Clojure embraces the use of literals for lists and maps.</p>

<h2>Filling a list:</h2>

<p>Sometimes you&rsquo;ll want to fill a list with repeated values, i.e. if you are using a list to record, say, the initial state of a game. The game state would be based on how many pieces are on the board in this case, which we represent as strings inside of a list.</p>

<h4>Scala</h4>

<p><code>
val gamePieces: List[String] = List.fill(10)("piece")
// gamePieces: List[String] = List(piece, piece, piece, piece, piece, piece, piece, piece, piece, piece)
</code></p>

<h4>Clojure</h4>

<p><code>clojure
(repeat 10 "piece")
;; ("piece" "piece" "piece" "piece" "piece" "piece" "piece" "piece" "piece" "piece")
</code></p>

<h2>Acquiring a range:</h2>

<p>In Java, one might write something like this to get a list of integers 0 &ndash; 10 exclusive:</p>

<h4>Java</h4>

<p>``` java
int[] myInts = new int[10];</p>

<p>for (int i = 0; i &lt; myInts.length; i++) {
  myInts[i] = i;
}
```</p>

<p>In Scala or Clojure, we can simplify our approach as follows:</p>

<h4>Scala</h4>

<p><code>scala
List.range(0, 10)
// res13: List[Int] = List(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
</code></p>

<h4>Clojure</h4>

<p><code>clojure
(range 0 10)
;; (0 1 2 3 4 5 6 7 8 9)
</code></p>

<h2>Applying functions to lists with map</h2>

<p>Most of the time, we will want to do more than just create lists,  we want to interact with the data inside of our lists, applying changes to them, etc. To do this, we can use the map function. Map takes a list and applies some function to each element in the list. Provided here are some map usage examples:</p>

<h4>Scala</h4>

<p><code>scala
gamePieces.map(a =&gt; a + 1)
// res17: List[String] = List(piece1, piece1, piece1, piece1, piece1, piece1, piece1, piece1, piece1, piece1)
</code></p>

<p><em>Notice how in Scala, the value of 1 is coerced to a String. This is a noteworthy difference between the two. Clojure will happily compile the equivalent code for us, but will throw a ClassCastException (RuntimeException) when we attempt to invoke the method or evaluate the var:</em></p>

<h4>Clojure</h4>

<p><code>clojure
(let [pieces (repeat 10 "piece")]
  (map #(+ % 1) pieces))
;; ClassCastException java.lang.String cannot be cast to java.lang.Number  clojure.lang.Numbers.add (Numbers.java:126)
</code></p>

<p>We can get around this using the str function, which will coerce its args to Strings and combine them into a single string:</p>

<h4>Clojure</h4>

<p><code>clojure
(let [pieces (repeat 10 "piece")]
  (map #(str % 1) pieces))
;; ("piece1" "piece1" "piece1" "piece1" "piece1" "piece1" "piece1" "piece1" "piece1" "piece1")
</code></p>

<p>In both examples, you can see that I have passed some instruction to the map function, similar to a method. These are referred to as anonymous functions, or lambdas. Here we make all of our list members scream loudly:</p>

<h4>Scala</h4>

<p><code>scala
gamePieces.map(a =&gt; a.toUpperCase)
// res21: List[String] = List(PIECE, PIECE, PIECE, PIECE, PIECE, PIECE, PIECE, PIECE, PIECE, PIECE)
</code></p>

<h4>Clojure</h4>

<p><code>clojure
(let [pieces (repeat 10 "piece")]
  (map clojure.string/upper-case pieces))
;; ("PIECE" "PIECE" "PIECE" "PIECE" "PIECE" "PIECE" "PIECE" "PIECE" "PIECE" "PIECE")
</code></p>

<h2>Getting relevant data with filter</h2>

<p>There will come a time when you will have a list and you will want to extract certain values from it. For this, we can use the filter functions that Scala and Clojure provide to slice and dice our data. Lets have some fun with an example involving Hobbits (inspired by <a href="https://twitter.com/nonrecursive">nonrecursive</a> at <a href="http://www.braveclojure.com/6-do-things/#3_10__Hobbit_Violence">braveclojure</a>):</p>

<h4>Scala</h4>

<p>``` scala
val names= List(&ldquo;Bilbo Baggins&rdquo;,</p>

<pre><code>            "Frodo Baggins", 
            "Samwise Gamgee", 
            "Peregrin 'Pippin' Took", 
            "Meradoc 'Merry' Brandybuck")
</code></pre>

<p>// hobbits: List[String] = List(Bilbo Baggins, Frodo Baggins, Samwise Gamgee, Peregrin &lsquo;Pippin&rsquo; Took, Meradoc &lsquo;Merry&rsquo; Brandybuck)
```</p>

<h4>Clojure</h4>

<p><code>clojure
["Bilbo Baggins”
 "Frodo Baggins"
 "Samwise Gamgee"
 "Peregrin 'Pippin' Took"
 "Meriadoc 'Merry' Brandybuck"]
;; ["Bilbo Baggins" "Frodo Baggins" "Samwise Gamgee" "Peregrin 'Pippin' Took" "Meriadoc 'Merry' Brandybuck"]
</code></p>

<p>Now we have a list of famous hobbits, great! Chance has it that I&rsquo;m throwing a special hobbit party, but only the Bagginses are invited. We need to get rid of everyone that&rsquo;s not a Baggins. Let&rsquo;s filter out the Bagginses and get with the merriment already!</p>

<h4>Scala</h4>

<p><code>scala
names.filter(a =&gt; a.endsWith("Baggins"))
// res77: List[String] = List(Bilbo Baggins, Frodo Baggins)
// Party time
</code></p>

<h4>Clojure</h4>

<p>``` clojure
(let [names [&ldquo;Bilbo Baggins&rdquo;</p>

<pre><code>         "Frodo Baggins"
         "Samwise Gamgee"
         "Peregrin 'Pippin' Took"
         "Meriadoc 'Merry' Brandybuck"]
  bagginses (filter #(re-find #".*Baggins" %) names)]
</code></pre>

<p>  (map #(str % &ldquo; is soOOOOOO DRUNK!!&rdquo;) bagginses))
;; (&ldquo;Bilbo Baggins is soOOOOOO DRUNK!!&rdquo; &ldquo;Frodo Baggins is soOOOOOO DRUNK!!&rdquo;)
```</p>

<p>Awesome! Now let&rsquo;s turn to a slightly more complex example &ndash; let&rsquo;s take on the role of Gollum and hunt for The Ring. The goal is to kill the hobbit with the precious and take it back for us. Let&rsquo;s find and kill the dirty lying hobbitses that has our precious!</p>

<h4>Scala</h4>

<p>``` scala
val hobbits: List[Map[String, Any]] = names.map(a => Map(&ldquo;name&rdquo; &ndash;> a, &ldquo;height&rdquo; &ndash;> &ldquo;small&rdquo;, &ldquo;hairyFeet&rdquo; &ndash;> true, &ldquo;hasPrecious?&rdquo; &ndash;> (if (a startsWith &ldquo;Frodo&rdquo;) true else false)))
// res83: List[scala.collection.immutable.Map[String,Any]] =
// List(Map(name &ndash;> Bilbo Baggins, height &ndash;> small, hairyFeet? &ndash;> true, hasPrecious? &ndash;> false),
//      Map(name &ndash;> Frodo Baggins, height &ndash;> small, hairyFeet? &ndash;> true, hasPrecious? &ndash;> true),
//      Map(name &ndash;> Samwise Gamgee, height &ndash;> small, hairyFeet? &ndash;> true, hasPrus? &ndash;> false),
//      Map(name &ndash;> Peregrin &lsquo;Pippin&rsquo; Took, height &ndash;> small, hairyFeet? &ndash;> true, hasPrecious? &ndash;> false),
//      Map(name &ndash;> Meradoc &lsquo;Merry&rsquo; Brandybuck, height &ndash;> small, hairyFeet? &ndash;> true, hasPrecious? &ndash;> false))</p>

<p>hobbits.filter((a: Map[String, Any]) => a.get(&ldquo;hasPrecious?&rdquo;) == Some(false))
// res84: List[Map[String,Any]] =
// List(Map(name &ndash;> Bilbo Baggins, height &ndash;> small, hairyFeet &ndash;> true, hasPrecious? &ndash;> false),
//      Map(name &ndash;> Samwise Gamgee, height &ndash;> small, hairyFeet &ndash;> true, hasPrecious? &ndash;> false),
//      Map(name &ndash;> Peregrin &lsquo;Pippin&rsquo; Took, height &ndash;> small, hairyFeet &ndash;> true, hasPrecious? &ndash;> false),
//      Map(name &ndash;> Meradoc &lsquo;Merry&rsquo; Brandybuck, height &ndash;> small, hairyFeet &ndash;> true, hasPrecious? &ndash;> false))
```</p>

<p>Having to deal with Some() is kind of ugly, so instead of a mixed-value map, we’ll switch to a case class. Here is the full implementation:</p>

<p>``` scala</p>

<p>object KillHobbits {</p>

<p>case class Hobbit(name: String, height: String, hairyFeet: Boolean, hasPrecious: Boolean)</p>

<p>  def main(args: Array[String]) {</p>

<pre><code>val names: List[String] = List("Bilbo Baggins", 
                               "Frodo Baggins", 
                               "Samwise Gamgee", 
                               "Peregrin 'Pippin' Took", 
                               "Meradoc 'Merry' Brandybuck")

val hobbits: List[Hobbit] = makeHobbits(names)
println("Before killing off the one holding the ring...")
hobbits.foreach(a =&gt; println(a))
val killTheRingKeeper: List[Hobbit] = hobbits.filter(a =&gt; a.hasPrecious == false)
println("\nDie dirty hobbitses!")
killTheRingKeeper.foreach(a =&gt; println(a))
</code></pre>

<p>  }</p>

<p>  def makeHobbits(names: List[String]): List[Hobbit] = {</p>

<pre><code>names.map(a =&gt; 
  Hobbit(name = a, 
         height = "hobbit-sized", 
         hairyFeet = true, 
         hasPrecious = if (a startsWith "Frodo") true else false))
</code></pre>

<p>  }</p>

<p>}</p>

<p>```</p>

<h4>Clojure</h4>

<p>``` clojure
(let [names [&ldquo;Bilbo Baggins&rdquo;</p>

<pre><code>         "Frodo Baggins"
         "Samwise Gamgee"
         "Peregrin 'Pippin' Took"
         "Meriadoc 'Merry' Brandybuck"]
  hobbits (vec (map #(hash-map :name %     
                               :height "hobbit-sized"
                               :hairy-feet? true
                               :has-precious? (if (= % "Frodo Baggins") true
                                                  false)) names))]
</code></pre>

<p>  (filter :has-precious? hobbits))
;; ({:name &ldquo;Frodo Baggins&rdquo;, :hairy-feet? true, :has-precious? true, :height &ldquo;hobbit-sized&rdquo;})
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Recursion in Scala]]></title>
    <link href="http://rxacevedo.github.io/blog/2013/04/08/recursion-in-scala/"/>
    <updated>2013-04-08T19:33:00-04:00</updated>
    <id>http://rxacevedo.github.io/blog/2013/04/08/recursion-in-scala</id>
    <content type="html"><![CDATA[<p>I&rsquo;ve been going through Martin Odersky&rsquo;s free course on Coursera, <a href="https://www.coursera.org/course/progfun">Functional
Programming Principles in Scala</a>, and
I must say that it&rsquo;s prompted me to think in ways that I&rsquo;ve never had to before.
The course starts off teaching by teaching you how basic logic and arithmetic
operators work in Scala, but then quickly dives into recursive functions and
how to use them. In order to help me develop a more concrete
understanding of the concept, and to help anyone else that may be
struggling with it themselves, I&rsquo;ve decided to write this blog post to share
what I have learned so far.</p>

<p>Recursive functions are functions that call themselves. This post will focus on
what is called tail-recursion, altough there are also head-recursive functions.
Basically (as far as I understand it), tail-recursion is when a function <em>does
stuff</em> and then calls itself as the last step of it&rsquo;s defintion. Head
recursion, on the other hand, is when a function calls itself at the beginning
of its defition, saving that iterations state when the call is made, then
executing any other instructions when the recursive call returns (this would
then happen for each recursive call). A better explanation can be found
<a href="http://www.cs.cmu.edu/~adamchik/15-121/lectures/Recursions/recursions.html">here</a>.</p>

<p>Consider the following function:</p>

<p><code>scala
def sum(a: Int, b: Int): Int = if(a == b) a else a + sum(a + 1, b)
</code></p>

<p>Note that the last thing that this function does is call itself. This is a
recursive function in the sense that it is calling itself. As the name
implies, this function will return the sum of parameters a and b. Since the
execution of this wasn&rsquo;t initially evident to me, let&rsquo;s trace it out:</p>

<pre><code>Call 1: a = 1, b = 5 =&gt; sum(1, 5) =&gt; (a == b) ? false =&gt; 1 + sum(1 + 1, 5) 
Call 2: a = 2, b = 5 =&gt; sum(2, 5) =&gt; (a == b) ? false =&gt; 2 + sum(2 + 1, 5) 
Call 3: a = 1, b = 5 =&gt; sum(3, 5) =&gt; (a == b) ? false =&gt; 3 + sum(3 + 1, 5) 
Call 4: a = 1, b = 5 =&gt; sum(4, 5) =&gt; (a == b) ? false =&gt; 4 + sum(4 + 1, 5) 
Call 5: a = 1, b = 5 =&gt; sum(5, 5) =&gt; (a == b) ? true =&gt; 5 
</code></pre>

<p>The evaluation of a and b&rsquo;s equality is the exit condition, or <strong>base
case</strong>. This is necessary with recursive functions, or else execution will go
on forever. Try omitting that and see what happens if you&rsquo;d like (it&rsquo;ll blow up
in your face). We can see that at the fifth call, our exit condition
evaluates to true, so we return a itself, which is in this case 5. Where do we
return it? To the previous call. Let&rsquo;s further simplify:</p>

<p><code>scala
sum(1,5)
1 + sum(2, 5)
1 + (2 + sum(3, 5))
1 + (2 + (3 + sum(4, 5)))
1 + (2 + (3 + (4 + sum(5, 5))))
1 + (2 + (3 + (4 + (5)))) == 15 // True statement
</code></p>

<p>So now we have computed the sum of the numbers between 1 through 5. What if we
wanted to compute the product of these numbers? The key here is that our
function drills down until it reaches the termination condition, then it
&ldquo;shoots back up&rdquo; and does an operation on the returned value for each call.
Because we are already returning 5, 4 + (return), 3 + (return), 2 + (return),
and 1 + (return), we already have the basic layout that we want. We want to get
to here: 5, 4 * (return), 3 * (return), 2 * (return), 1 * (return). This is
already starting to look like a factorial function, but we&rsquo;re not quite there
yet. Let&rsquo;s redefine our function to calculate the <strong>product</strong> of the integers
in range (a, b):</p>

<p><code>scala
def product(a: Int, b: Int): Int = if(a == b) a else a * product(a + 1, b)
</code></p>

<p>The same thing will happen, only when we reach our termination condition, we
will multiply that by our current <em>a</em> value instead of adding it. Let&rsquo;s test that:</p>

<p><code>
scala&gt; product(1, 5)
res21: Int = 120
</code></p>

<p>So now we have the product, and we only had to change the operator that we
used. Since we are so close, let&rsquo;s go ahead implement a factorial function. We want our
factorial function to take one argument instead of two, we&rsquo;ll call it x:</p>

<p><code>scala
def factorial(x: Int): Int = ???
</code></p>

<p>Some caveats here, we want to give the function our maxiumum argument, and
calculate recursively going <strong>down</strong>. We&rsquo;ll have to tweak the function a little
bit to do that. We know that:</p>

<ul>
<li>We have to decrement our argument for each recursive call</li>
<li>We&rsquo;ll want to terminate at some point</li>
</ul>


<p><code>scala
def factorial(x: Int): Int = if(???) ??? else x * factorial(x - 1)
</code></p>

<p>We want to multiply our inital value by what is returned by the recursive call,
that call being on the current argument decremented by 1. When should we
terminate though, and what should we return? I have a habit of checking if a
value is 0, and one <em>could</em> return 1 when this is met , but that would give us
an extra one, 5 * 4 * 3 * 2 * 1 * 1, which is an innocuous value to multiply
by, but increases the depth of our call stack nonetheless. In this case it&rsquo;s not
necessary, since 5 * 4 * 3 * 2 * 1 will give us our answer. We should check
when we have reached 1 (and that our input is not negative), and return 1 (to multiply by) in that case. Our new
definition looks like this:</p>

<p><code>scala
def factorial(x: Int): Int = if(x &gt;= 1) 1 else x * factorial(x - 1)
</code></p>

<p>Now let&rsquo;s run that puppy:</p>

<p><code>
scala&gt; factorial(5)
res22: Int = 120
</code></p>

<p>And we get what we expected.</p>

<p>Now, this <em>looks</em> very elegant, doesn&rsquo;t it? Well, we can further simplify.
If you look back up at the execution of the method, you&rsquo;ll see that we have to
remember the value of every single iteration, all the way up the
chain. Our expression grows with each execution, not so much for the sum of 15,
but you can imagine how quickly it would grow for factorial(200) (well, that returns
infinity using type Double). What we need is a function that doesn&rsquo;t depend on
all previous iterations, one that is given every value that it needs to compute
the value for that iteration, instead of having to run all the way up the
heirarchy, doing a sum (or multiplication) for each call (within the arguments).
We can do this by defining an inner function and supplying it with a seed value.
Lets start with our sum function:</p>

<p>``` scala
def sum(a: Int, b: Int) = {
  def inner(acc: Int, a: Int, b: Int): Int = if (a > b) acc else inner(acc + a, a + 1, b)</p>

<pre><code>inner(0, a, b)
</code></pre>

<p>}
```</p>

<p>In this implementation, we define an inner function that takes three arguments:
our two previous arguments, and an accumulator. Accumulator is your friend,
because by passing him into the function each time, we avoid having to keep
track of what&rsquo;s going on in the call hierarchy above us, we have everything we
need because accumulator is storing a running total. Also notice that our
function does not have to do any calculations upon returning, unlike the
previous implementation that needed to add a to the return value. This function
is <strong>tail recursive</strong>. We can take advantage of the accumulator and use the
same approach with our product and factorial functions:</p>

<p>``` scala
def product(a: Int, b: Int) = {
  def inner(acc: Int, a: Int, b: Int): Int = if (a > b) acc else inner(acc * a, a + 1, b)</p>

<pre><code>inner(1, a, b)
</code></pre>

<p>}
```</p>

<p>Note that we seed 1 to this function instead of 0 since we don&rsquo;t want to
multiply by zero.</p>

<p>Factorial is just as easy:</p>

<p>``` scala
def factorial(a: Int) = {
  def inner(acc: Int, a: Int): Int = if (a == 0) acc else inner(acc * a, a &ndash; 1)</p>

<pre><code>inner(1, a)
</code></pre>

<p>}
```</p>

<p>By doing this, we can reuse the same stack frame for each call. This is in
contrast to our previous approaches, which required that we push onto the stack
for each consecutive calculation and call, then pop each return off the
stack in order to arrive at our final value. The first approach is a <strong>recursive process</strong>, whereas the second is called an <strong>iterative process.</strong></p>
]]></content>
  </entry>
  
</feed>
